import dotenv from 'dotenv';
import { InstagramBot } from './core/InstagramBot.js';
import { TelegramBridge } from './bridge/TelegramBridge.js';
import { PluginManager } from './plugins/PluginManager.js';
import { logger } from './utils.js';

dotenv.config();

class InstagramUserBot {
  constructor() {
    this.instagramBot = new InstagramBot();
    this.telegramBridge = new TelegramBridge();
    this.pluginManager = new PluginManager();
  }

  async initialize() {
    try {
      logger.info('🚀 Starting Instagram UserBot...');
      
      // Initialize Instagram connection
      await this.instagramBot.login();
      
      // Initialize Telegram bridge
      await this.telegramBridge.initialize();
      
      // Load plugins
      await this.pluginManager.loadPlugins();
      
      // Set up message handlers
      this.setupMessageHandlers();
      
      logger.info('✅ Instagram UserBot initialized successfully!');
      
    } catch (error) {
      logger.error('❌ Failed to initialize bot:', error);
      process.exit(1);
    }
  }

  setupMessageHandlers() {
    // Handle incoming Instagram messages
    this.instagramBot.onMessage(async (message) => {
      try {
        // Process through plugins
        const processedMessage = await this.pluginManager.processMessage(message);
        
        // Forward to Telegram if enabled
        if (processedMessage.shouldForward) {
          await this.telegramBridge.forwardMessage(processedMessage);
        }
      } catch (error) {
        logger.error('Error processing message:', error);
      }
    });

    // Handle media messages
    this.instagramBot.onMedia(async (media) => {
      try {
        await this.telegramBridge.forwardMedia(media);
      } catch (error) {
        logger.error('Error forwarding media:', error);
      }
    });
  }

  async start() {
    await this.initialize();
    
    // Keep the bot running
    process.on('SIGINT', async () => {
      logger.info('🛑 Shutting down bot...');
      await this.instagramBot.disconnect();
      await this.pluginManager.unloadPlugins();
      process.exit(0);
    });

    logger.info('🤖 Bot is running... Press Ctrl+C to stop');
  }
}

// Start the bot
const bot = new InstagramUserBot();
bot.start().catch(console.error);



export const config = {
  instagram: {
    username: process.env.INSTAGRAM_USERNAME,
    password: process.env.INSTAGRAM_PASSWORD,
    sessionPath: './session/instagram_session.json',
    messageCheckInterval: 5000, // Check for messages every 5 seconds
    maxRetries: 3
  },
  
  telegram: {
    botToken: process.env.TELEGRAM_BOT_TOKEN,
    chatId: process.env.TELEGRAM_CHAT_ID,
    forwardMessages: process.env.FORWARD_MESSAGES !== 'false',
    forwardMedia: process.env.FORWARD_MEDIA !== 'false'
  },
  
  plugins: {
    autoReply: {
      enabled: process.env.AUTO_REPLY_ENABLED === 'true',
      greetings: ['hello', 'hi', 'hey', 'good morning', 'good evening'],
      responses: [
        'Hello! Thanks for your message.',
        'Hi there! I\'ll get back to you soon.',
        'Hey! Thanks for reaching out.'
      ]
    },
    
    messageFilter: {
      enabled: process.env.MESSAGE_FILTER_ENABLED === 'true',
      blockedUsers: (process.env.BLOCKED_USERS || '').split(',').filter(Boolean),
      spamKeywords: ['spam', 'promotion', 'offer', 'deal', 'discount']
    },
    
    messageLogger: {
      enabled: process.env.MESSAGE_LOGGER_ENABLED !== 'false',
      logPath: './logs/messages.json',
      maxLogSize: 1000 // Maximum number of messages to keep
    }
  },
  
  app: {
    logLevel: process.env.LOG_LEVEL || 'info',
    environment: process.env.NODE_ENV || 'development'
  }
};







import fs from 'fs-extra';
import path from 'path';

// Simple logger utility
export const logger = {
  info: (message, ...args) => {
    console.log(`[${new Date().toISOString()}] ℹ️  ${message}`, ...args);
  },
  
  error: (message, ...args) => {
    console.error(`[${new Date().toISOString()}] ❌ ${message}`, ...args);
  },
  
  warn: (message, ...args) => {
    console.warn(`[${new Date().toISOString()}] ⚠️  ${message}`, ...args);
  },
  
  debug: (message, ...args) => {
    if (process.env.LOG_LEVEL === 'debug') {
      console.log(`[${new Date().toISOString()}] 🐛 ${message}`, ...args);
    }
  }
};

// File utilities
export const fileUtils = {
  async ensureDir(dirPath) {
    await fs.ensureDir(dirPath);
  },
  
  async readJson(filePath) {
    try {
      return await fs.readJson(filePath);
    } catch (error) {
      return null;
    }
  },
  
  async writeJson(filePath, data) {
    await fs.ensureDir(path.dirname(filePath));
    await fs.writeJson(filePath, data, { spaces: 2 });
  },
  
  async pathExists(filePath) {
    return await fs.pathExists(filePath);
  }
};

// Message utilities
export const messageUtils = {
  formatMessage(message) {
    return {
      id: message.id,
      text: message.text || '',
      sender: message.senderUsername || 'Unknown',
      timestamp: message.timestamp,
      thread: message.threadTitle || 'Direct Message',
      type: message.type || 'text'
    };
  },
  
  isSpam(text, spamKeywords) {
    if (!text || !spamKeywords.length) return false;
    
    const lowerText = text.toLowerCase();
    return spamKeywords.some(keyword => lowerText.includes(keyword.toLowerCase()));
  },
  
  containsGreeting(text, greetings) {
    if (!text || !greetings.length) return false;
    
    const lowerText = text.toLowerCase();
    return greetings.some(greeting => lowerText.includes(greeting.toLowerCase()));
  }
};

// Random utilities
export const randomUtils = {
  choice(array) {
    return array[Math.floor(Math.random() * array.length)];
  },
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
};
import { IgApiClient } from 'instagram-private-api';
import { logger, fileUtils } from '../utils.js';
import { config } from '../config.js';

export class InstagramBot {
  constructor() {
    this.ig = new IgApiClient();
    this.messageHandlers = [];
    this.mediaHandlers = [];
    this.sessionPath = config.instagram.sessionPath;
    this.isRunning = false;
  }

  async login() {
    try {
      // Load existing session if available
      await this.loadSession();
      
      this.ig.state.generateDevice(config.instagram.username);
      
      // Try to login with existing session first
      try {
        await this.ig.account.currentUser();
        logger.info('✅ Logged in with existing session');
        this.startMessageListener();
        return;
      } catch (error) {
        logger.info('🔄 Existing session invalid, logging in with credentials...');
      }

      // Login with username and password
      await this.ig.account.login(
        config.instagram.username,
        config.instagram.password
      );
      
      // Save session
      await this.saveSession();
      
      logger.info('✅ Successfully logged into Instagram');
      
      // Start listening for messages
      this.startMessageListener();
      
    } catch (error) {
      logger.error('❌ Instagram login failed:', error.message);
      throw error;
    }
  }

  async loadSession() {
    try {
      if (await fileUtils.pathExists(this.sessionPath)) {
        const sessionData = await fileUtils.readJson(this.sessionPath);
        if (sessionData) {
          await this.ig.state.deserialize(sessionData);
          logger.info('📱 Loaded Instagram session');
        }
      }
    } catch (error) {
      logger.warn('⚠️ Could not load session:', error.message);
    }
  }

  async saveSession() {
    try {
      const serialized = await this.ig.state.serialize();
      delete serialized.constants;
      await fileUtils.writeJson(this.sessionPath, serialized);
      logger.info('💾 Instagram session saved');
    } catch (error) {
      logger.warn('⚠️ Could not save session:', error.message);
    }
  }

  startMessageListener() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    logger.info('👂 Started message listener');
    
    // Check for messages periodically
    setInterval(async () => {
      if (this.isRunning) {
        try {
          await this.checkForNewMessages();
        } catch (error) {
          logger.error('Error checking messages:', error);
        }
      }
    }, config.instagram.messageCheckInterval);
  }

  async checkForNewMessages() {
    try {
      const inbox = await this.ig.feed.directInbox().items();
      
      for (const thread of inbox) {
        const messages = await this.ig.feed.directThread({
          thread_id: thread.thread_id
        }).items();
        
        // Only check the latest message
        for (const message of messages.slice(0, 1)) {
          if (this.isNewMessage(message)) {
            await this.handleMessage(message, thread);
          }
        }
      }
    } catch (error) {
      logger.error('Error fetching messages:', error);
    }
  }

  isNewMessage(message) {
    // Simple check - in production, you'd track processed message IDs
    const messageAge = Date.now() - (message.timestamp / 1000);
    return messageAge < 10000; // Messages newer than 10 seconds
  }

  async handleMessage(message, thread) {
    const processedMessage = {
      id: message.item_id,
      text: message.text || '',
      sender: message.user_id,
      senderUsername: thread.users.find(u => u.pk === message.user_id)?.username || 'Unknown',
      timestamp: new Date(message.timestamp / 1000),
      threadId: thread.thread_id,
      threadTitle: thread.thread_title || 'Direct Message',
      type: message.item_type,
      shouldForward: true
    };

    // Handle media messages
    if (message.media) {
      processedMessage.media = {
        type: message.media.media_type === 1 ? 'photo' : 'video',
        url: message.media.image_versions2?.candidates?.[0]?.url || 
             message.media.video_versions?.[0]?.url
      };
      
      // Notify media handlers
      for (const handler of this.mediaHandlers) {
        await handler(processedMessage);
      }
    }

    // Notify message handlers
    for (const handler of this.messageHandlers) {
      await handler(processedMessage);
    }
  }

  onMessage(handler) {
    this.messageHandlers.push(handler);
  }

  onMedia(handler) {
    this.mediaHandlers.push(handler);
  }

  async sendMessage(threadId, text) {
    try {
      await this.ig.entity.directThread(threadId).broadcastText(text);
      logger.info(`📤 Sent message to thread ${threadId}`);
    } catch (error) {
      logger.error('Error sending message:', error);
    }
  }

  async disconnect() {
    logger.info('🔌 Disconnecting from Instagram...');
    this.isRunning = false;
    await this.saveSession();
  }
}


# Instagram Credentials
INSTAGRAM_USERNAME=your_instagram_username
INSTAGRAM_PASSWORD=your_instagram_password

# Telegram Bot Configuration
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
TELEGRAM_CHAT_ID=your_telegram_chat_id

# Message Forwarding Settings
FORWARD_MESSAGES=true
FORWARD_MEDIA=true

# Plugin Settings
AUTO_REPLY_ENABLED=false
MESSAGE_FILTER_ENABLED=true
MESSAGE_LOGGER_ENABLED=true

# Message Filter Settings
BLOCKED_USERS=user1,user2,user3
SPAM_KEYWORDS=spam,promotion,offer

# App Settings
LOG_LEVEL=info
NODE_ENV=development










import { AutoReplyPlugin } from './AutoReplyPlugin.js';
import { MessageFilterPlugin } from './MessageFilterPlugin.js';
import { MessageLoggerPlugin } from './MessageLoggerPlugin.js';
import { logger } from '../utils.js';
import { config } from '../config.js';

export class PluginManager {
  constructor() {
    this.plugins = [];
  }

  async loadPlugins() {
    try {
      logger.info('🔌 Loading plugins...');

      // Load AutoReply plugin
      if (config.plugins.autoReply.enabled) {
        const autoReply = new AutoReplyPlugin();
        this.plugins.push(autoReply);
        logger.info('✅ AutoReply plugin loaded');
      }

      // Load MessageFilter plugin
      if (config.plugins.messageFilter.enabled) {
        const messageFilter = new MessageFilterPlugin();
        this.plugins.push(messageFilter);
        logger.info('✅ MessageFilter plugin loaded');
      }

      // Load MessageLogger plugin
      if (config.plugins.messageLogger.enabled) {
        const messageLogger = new MessageLoggerPlugin();
        this.plugins.push(messageLogger);
        logger.info('✅ MessageLogger plugin loaded');
      }

      logger.info(`🎉 Loaded ${this.plugins.length} plugins`);

    } catch (error) {
      logger.error('❌ Error loading plugins:', error);
    }
  }

  async processMessage(message) {
    let processedMessage = { ...message };

    for (const plugin of this.plugins) {
      try {
        processedMessage = await plugin.process(processedMessage);
        
        // If a plugin marks the message as not to be forwarded, stop processing
        if (!processedMessage.shouldForward) {
          break;
        }
      } catch (error) {
        logger.error(`Error in plugin ${plugin.constructor.name}:`, error);
      }
    }

    return processedMessage;
  }

  getPlugin(name) {
    return this.plugins.find(plugin => plugin.constructor.name === name);
  }

  async unloadPlugins() {
    for (const plugin of this.plugins) {
      if (plugin.cleanup) {
        await plugin.cleanup();
      }
    }
    this.plugins = [];
    logger.info('🔌 All plugins unloaded');
  }
}











import TelegramBot from 'node-telegram-bot-api';
import axios from 'axios';
import { logger, fileUtils } from '../utils.js';
import { config } from '../config.js';

export class TelegramBridge {
  constructor() {
    this.bot = null;
    this.chatId = config.telegram.chatId;
  }

  async initialize() {
    try {
      if (!config.telegram.botToken) {
        logger.warn('⚠️ Telegram bot token not provided, skipping Telegram integration');
        return;
      }

      this.bot = new TelegramBot(config.telegram.botToken, { polling: false });
      
      // Test the connection
      const me = await this.bot.getMe();
      logger.info(`✅ Connected to Telegram as @${me.username}`);
      
    } catch (error) {
      logger.error('❌ Failed to initialize Telegram bridge:', error.message);
      throw error;
    }
  }

  async forwardMessage(message) {
    if (!this.bot || !config.telegram.forwardMessages) return;

    try {
      const formattedMessage = this.formatMessage(message);
      await this.bot.sendMessage(this.chatId, formattedMessage, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true
      });
      
      logger.info(`📨 Forwarded message from @${message.senderUsername} to Telegram`);
      
    } catch (error) {
      logger.error('Error forwarding message to Telegram:', error);
    }
  }

  async forwardMedia(message) {
    if (!this.bot || !config.telegram.forwardMedia || !message.media) return;

    try {
      const caption = this.formatMessage(message);
      
      if (message.media.type === 'photo') {
        await this.bot.sendPhoto(this.chatId, message.media.url, {
          caption,
          parse_mode: 'Markdown'
        });
      } else if (message.media.type === 'video') {
        await this.bot.sendVideo(this.chatId, message.media.url, {
          caption,
          parse_mode: 'Markdown'
        });
      }
      
      logger.info(`🖼️ Forwarded ${message.media.type} from @${message.senderUsername} to Telegram`);
      
    } catch (error) {
      logger.error('Error forwarding media to Telegram:', error);
    }
  }

  formatMessage(message) {
    const timestamp = message.timestamp.toLocaleString();
    const sender = message.senderUsername;
    const thread = message.threadTitle;
    const text = message.text || '[Media]';
    
    return `📱 *Instagram Message*\n\n` +
           `👤 *From:* @${sender}\n` +
           `💬 *Thread:* ${thread}\n` +
           `🕒 *Time:* ${timestamp}\n\n` +
           `💭 *Message:*\n${text}`;
  }

  async sendNotification(text) {
    if (!this.bot) return;

    try {
      await this.bot.sendMessage(this.chatId, `🤖 *Bot Notification*\n\n${text}`, {
        parse_mode: 'Markdown'
      });
    } catch (error) {
      logger.error('Error sending notification to Telegram:', error);
    }
  }

  async downloadMedia(url, filename) {
    try {
      const response = await axios({
        method: 'GET',
        url: url,
        responseType: 'stream'
      });

      await fileUtils.ensureDir('./downloads');
      const filePath = `./downloads/${filename}`;
      
      const writer = fs.createWriteStream(filePath);
      response.data.pipe(writer);

      return new Promise((resolve, reject) => {
        writer.on('finish', () => resolve(filePath));
        writer.on('error', reject);
      });
      
    } catch (error) {
      logger.error('Error downloading media:', error);
      throw error;
    }
  }
}












import { IgApiClient } from 'instagram-private-api';
import { logger, fileUtils } from '../utils.js';
import { config } from '../config.js';

export class InstagramBot {
  constructor() {
    this.ig = new IgApiClient();
    this.messageHandlers = [];
    this.mediaHandlers = [];
    this.sessionPath = config.instagram.sessionPath;
    this.isRunning = false;
  }

  async login() {
    try {
      // Load existing session if available
      await this.loadSession();
      
      this.ig.state.generateDevice(config.instagram.username);
      
      // Try to login with existing session first
      try {
        await this.ig.account.currentUser();
        logger.info('✅ Logged in with existing session');
        this.startMessageListener();
        return;
      } catch (error) {
        logger.info('🔄 Existing session invalid, logging in with credentials...');
      }

      // Login with username and password
      await this.ig.account.login(
        config.instagram.username,
        config.instagram.password
      );
      
      // Save session
      await this.saveSession();
      
      logger.info('✅ Successfully logged into Instagram');
      
      // Start listening for messages
      this.startMessageListener();
      
    } catch (error) {
      logger.error('❌ Instagram login failed:', error.message);
      throw error;
    }
  }

  async loadSession() {
    try {
      if (await fileUtils.pathExists(this.sessionPath)) {
        const sessionData = await fileUtils.readJson(this.sessionPath);
        if (sessionData) {
          await this.ig.state.deserialize(sessionData);
          logger.info('📱 Loaded Instagram session');
        }
      }
    } catch (error) {
      logger.warn('⚠️ Could not load session:', error.message);
    }
  }

  async saveSession() {
    try {
      const serialized = await this.ig.state.serialize();
      delete serialized.constants;
      await fileUtils.writeJson(this.sessionPath, serialized);
      logger.info('💾 Instagram session saved');
    } catch (error) {
      logger.warn('⚠️ Could not save session:', error.message);
    }
  }

  startMessageListener() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    logger.info('👂 Started message listener');
    
    // Check for messages periodically
    setInterval(async () => {
      if (this.isRunning) {
        try {
          await this.checkForNewMessages();
        } catch (error) {
          logger.error('Error checking messages:', error);
        }
      }
    }, config.instagram.messageCheckInterval);
  }

  async checkForNewMessages() {
    try {
      const inbox = await this.ig.feed.directInbox().items();
      
      for (const thread of inbox) {
        const messages = await this.ig.feed.directThread({
          thread_id: thread.thread_id
        }).items();
        
        // Only check the latest message
        for (const message of messages.slice(0, 1)) {
          if (this.isNewMessage(message)) {
            await this.handleMessage(message, thread);
          }
        }
      }
    } catch (error) {
      logger.error('Error fetching messages:', error);
    }
  }

  isNewMessage(message) {
    // Simple check - in production, you'd track processed message IDs
    const messageAge = Date.now() - (message.timestamp / 1000);
    return messageAge < 10000; // Messages newer than 10 seconds
  }

  async handleMessage(message, thread) {
    const processedMessage = {
      id: message.item_id,
      text: message.text || '',
      sender: message.user_id,
      senderUsername: thread.users.find(u => u.pk === message.user_id)?.username || 'Unknown',
      timestamp: new Date(message.timestamp / 1000),
      threadId: thread.thread_id,
      threadTitle: thread.thread_title || 'Direct Message',
      type: message.item_type,
      shouldForward: true
    };

    // Handle media messages
    if (message.media) {
      processedMessage.media = {
        type: message.media.media_type === 1 ? 'photo' : 'video',
        url: message.media.image_versions2?.candidates?.[0]?.url || 
             message.media.video_versions?.[0]?.url
      };
      
      // Notify media handlers
      for (const handler of this.mediaHandlers) {
        await handler(processedMessage);
      }
    }

    // Notify message handlers
    for (const handler of this.messageHandlers) {
      await handler(processedMessage);
    }
  }

  onMessage(handler) {
    this.messageHandlers.push(handler);
  }

  onMedia(handler) {
    this.mediaHandlers.push(handler);
  }

  async sendMessage(threadId, text) {
    try {
      await this.ig.entity.directThread(threadId).broadcastText(text);
      logger.info(`📤 Sent message to thread ${threadId}`);
    } catch (error) {
      logger.error('Error sending message:', error);
    }
  }

  async disconnect() {
    logger.info('🔌 Disconnecting from Instagram...');
    this.isRunning = false;
    await this.saveSession();
  }
}

