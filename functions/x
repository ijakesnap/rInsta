import TelegramBot from 'node-telegram-bot-api';
import fs from 'fs-extra';
import path from 'path';
import axios from 'axios';
import sharp from 'sharp';
import { connectDb } from '../utils/db.js';
import { config } from '../config.js';
import { logger } from '../utils/logger.js';

export class TelegramBridge {
  constructor() {
    this.instagramBot = null;
    this.telegramBot = null;
    this.chatMappings = new Map();
    this.userMappings = new Map();
    this.profilePicCache = new Map();
    this.tempDir = path.join(process.cwd(), 'temp');
    this.db = null;
    this.collection = null;
    this.telegramChatId = null;
    this.creatingTopics = new Map();
    this.topicVerificationCache = new Map();
    this.enabled = false;
  }

  async initialize(instagramBotInstance) {
    this.instagramBot = instagramBotInstance;
    
    const token = config.telegram?.botToken;
    this.telegramChatId = config.telegram?.chatId;

    if (!token || !this.telegramChatId) {
      logger.warn('‚ö†Ô∏è Telegram configuration missing');
      return;
    }

    try {
      await this.initializeDatabase();
      await fs.ensureDir(this.tempDir);
      
      this.telegramBot = new TelegramBot(token, { polling: true });
      
      await this.setupTelegramHandlers();
      await this.loadMappingsFromDb();
      
      this.enabled = true;
      logger.info('‚úÖ Telegram bridge initialized');
    } catch (error) {
      logger.error('‚ùå Failed to initialize Telegram bridge:', error.message);
      this.enabled = false;
    }
  }

  async initializeDatabase() {
    try {
      this.db = await connectDb();
      this.collection = this.db.collection('bridge');
      
      await this.collection.createIndex(
        { type: 1, 'data.instagramThreadId': 1 }, 
        { unique: true, partialFilterExpression: { type: 'chat' } }
      );
      
      logger.info('üìä Database initialized for bridge');
    } catch (error) {
      logger.error('‚ùå Database initialization failed:', error.message);
      throw error;
    }
  }

  async loadMappingsFromDb() {
    if (!this.collection) return;
    
    try {
      const mappings = await this.collection.find({}).toArray();
      
      for (const mapping of mappings) {
        if (mapping.type === 'chat') {
          this.chatMappings.set(mapping.data.instagramThreadId, mapping.data.telegramTopicId);
          if (mapping.data.profilePicUrl) {
            this.profilePicCache.set(mapping.data.instagramThreadId, mapping.data.profilePicUrl);
          }
        } else if (mapping.type === 'user') {
          this.userMappings.set(mapping.data.instagramUserId, {
            username: mapping.data.username,
            fullName: mapping.data.fullName,
            profilePic: mapping.data.profilePic,
            firstSeen: mapping.data.firstSeen,
            messageCount: mapping.data.messageCount || 0
          });
        }
      }
      
      logger.info(`üìä Loaded mappings: ${this.chatMappings.size} chats, ${this.userMappings.size} users`);
    } catch (error) {
      logger.error('‚ùå Failed to load mappings:', error.message);
    }
  }

  async saveChatMapping(instagramThreadId, telegramTopicId, profilePicUrl = null) {
    if (!this.collection) return;
    
    try {
      const updateData = {
        type: 'chat',
        data: {
          instagramThreadId,
          telegramTopicId,
          profilePicUrl,
          createdAt: new Date(),
          lastActivity: new Date()
        }
      };

      await this.collection.updateOne(
        { type: 'chat', 'data.instagramThreadId': instagramThreadId },
        { $set: updateData },
        { upsert: true }
      );

      this.chatMappings.set(instagramThreadId, telegramTopicId);
      if (profilePicUrl) {
        this.profilePicCache.set(instagramThreadId, profilePicUrl);
      }

      logger.debug(`‚úÖ Saved chat mapping: ${instagramThreadId} -> ${telegramTopicId}`);
    } catch (error) {
      logger.error('‚ùå Failed to save chat mapping:', error.message);
    }
  }

  async saveUserMapping(instagramUserId, userData) {
    if (!this.collection) return;
    
    try {
      await this.collection.updateOne(
        { type: 'user', 'data.instagramUserId': instagramUserId },
        {
          $set: {
            type: 'user',
            data: {
              instagramUserId,
              username: userData.username,
              fullName: userData.fullName,
              profilePic: userData.profilePic,
              firstSeen: userData.firstSeen,
              messageCount: userData.messageCount || 0,
              lastSeen: new Date()
            }
          }
        },
        { upsert: true }
      );

      this.userMappings.set(instagramUserId, userData);
      logger.debug(`‚úÖ Saved user mapping: ${instagramUserId} (@${userData.username})`);
    } catch (error) {
      logger.error('‚ùå Failed to save user mapping:', error.message);
    }
  }

  async getOrCreateTopic(instagramThreadId, senderUserId, senderInfo) {
    if (this.chatMappings.has(instagramThreadId)) {
      return this.chatMappings.get(instagramThreadId);
    }

    if (this.creatingTopics.has(instagramThreadId)) {
      return await this.creatingTopics.get(instagramThreadId);
    }

    const creationPromise = this.createNewTopic(instagramThreadId, senderUserId, senderInfo);
    this.creatingTopics.set(instagramThreadId, creationPromise);
    
    try {
      const result = await creationPromise;
      return result;
    } finally {
      this.creatingTopics.delete(instagramThreadId);
    }
  }

  async createNewTopic(instagramThreadId, senderUserId, senderInfo) {
    try {
      // Get complete user info
      let userInfo = senderInfo;
      if (!userInfo && senderUserId) {
        userInfo = await this.instagramBot.getUserInfo(senderUserId);
      }

      const username = userInfo?.username || `user_${senderUserId}`;
      const fullName = userInfo?.full_name || 'Unknown User';
      const profilePicUrl = userInfo?.hd_profile_pic_url_info?.url || userInfo?.profile_pic_url;

      // Create topic with proper name
      const topicName = fullName !== 'Unknown User' ? `${fullName} (@${username})` : `@${username}`;
      
      const topic = await this.telegramBot.createForumTopic(this.telegramChatId, topicName, {
        icon_color: 0x7ABA3C
      });

      // Save mappings
      await this.saveChatMapping(instagramThreadId, topic.message_thread_id, profilePicUrl);
      
      if (senderUserId) {
        await this.saveUserMapping(senderUserId.toString(), {
          username,
          fullName,
          profilePic: profilePicUrl,
          firstSeen: new Date(),
          messageCount: 0
        });
      }

      // Send welcome message with complete profile
      await this.sendWelcomeMessage(topic.message_thread_id, instagramThreadId, userInfo);

      logger.info(`üÜï Created topic: "${topicName}" for thread ${instagramThreadId}`);
      return topic.message_thread_id;

    } catch (error) {
      logger.error('‚ùå Failed to create topic:', error.message);
      return null;
    }
  }

  escapeMarkdownV2(text) {
    if (!text) return '';
    const specialChars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!'];
    let escapedText = text.toString();
    
    specialChars.forEach(char => {
      const regex = new RegExp(`\\${char}`, 'g');
      escapedText = escapedText.replace(regex, `\\${char}`);
    });
    
    return escapedText;
  }

  async sendWelcomeMessage(topicId, instagramThreadId, userInfo) {
    try {
      const username = this.escapeMarkdownV2(userInfo?.username || 'Unknown');
      const fullName = this.escapeMarkdownV2(userInfo?.full_name || 'Unknown User');
      const userId = this.escapeMarkdownV2(userInfo?.pk?.toString() || 'N/A');
      const isVerified = userInfo?.is_verified ? '‚úÖ' : '';
      const isPrivate = userInfo?.is_private ? 'üîí' : 'üîì';
      const followerCount = userInfo?.follower_count ? this.escapeMarkdownV2(userInfo.follower_count.toLocaleString()) : 'N/A';
      const followingCount = userInfo?.following_count ? this.escapeMarkdownV2(userInfo.following_count.toLocaleString()) : 'N/A';
      const mediaCount = userInfo?.media_count ? this.escapeMarkdownV2(userInfo.media_count.toLocaleString()) : 'N/A';
      const biography = userInfo?.biography ? this.escapeMarkdownV2(userInfo.biography.substring(0, 200)) : 'No bio';

      const welcomeText = `üë§ *Instagram Profile Information*

üè∑Ô∏è *Name:* ${fullName} ${isVerified}
üìù *Username:* @${username}
üÜî *User ID:* ${userId}
${isPrivate} *Account:* ${userInfo?.is_private ? 'Private' : 'Public'}

üìä *Statistics:*
üë• Followers: ${followerCount}
‚û°Ô∏è Following: ${followingCount}
üì∏ Posts: ${mediaCount}

üìã *Bio:* ${biography}

üìÖ *First Contact:* ${new Date().toLocaleDateString()}
üí¨ Messages from this user will appear here`;

      const sentMessage = await this.telegramBot.sendMessage(this.telegramChatId, welcomeText, {
        message_thread_id: topicId,
        parse_mode: 'MarkdownV2'
      });

      await this.telegramBot.pinChatMessage(this.telegramChatId, sentMessage.message_id);

      // Send profile picture if available
      if (userInfo?.hd_profile_pic_url_info?.url || userInfo?.profile_pic_url) {
        const profilePicUrl = userInfo.hd_profile_pic_url_info?.url || userInfo.profile_pic_url;
        await this.sendProfilePicture(topicId, profilePicUrl);
      }

      logger.info(`üéâ Welcome message sent for ${userInfo?.username}`);
    } catch (error) {
      logger.error(`‚ùå Failed to send welcome message:`, error.message);
    }
  }

  async sendProfilePicture(topicId, profilePicUrl) {
    try {
      await this.telegramBot.sendPhoto(this.telegramChatId, profilePicUrl, {
        message_thread_id: topicId,
        caption: 'üì∏ Profile Picture'
      });
    } catch (error) {
      logger.error('‚ùå Failed to send profile picture:', error.message);
    }
  }

  async sendToTelegram(message) {
    if (!this.telegramBot || !this.enabled) return;

    try {
      const topicId = await this.getOrCreateTopic(
        message.threadId, 
        message.senderId, 
        {
          username: message.senderUsername,
          full_name: message.senderFullName,
          pk: message.senderId,
          profile_pic_url: message.senderProfilePic,
          is_verified: message.raw?.is_verified,
          is_private: message.raw?.is_private,
          follower_count: message.raw?.follower_count,
          following_count: message.raw?.following_count,
          media_count: message.raw?.media_count,
          biography: message.raw?.biography
        }
      );

      if (!topicId) return;

      // Update user message count
      if (this.userMappings.has(message.senderId.toString())) {
        const userData = this.userMappings.get(message.senderId.toString());
        userData.messageCount = (userData.messageCount || 0) + 1;
        await this.saveUserMapping(message.senderId.toString(), userData);
      }

      // Handle different message types
      await this.forwardMessageToTelegram(message, topicId);

    } catch (error) {
      logger.error('‚ùå Error forwarding to Telegram:', error.message);
    }
  }

  async forwardMessageToTelegram(message, topicId) {
    try {
      switch (message.type) {
        case 'text':
        case 'link':
          await this.sendSimpleMessage(topicId, message.text);
          break;

        case 'media':
          await this.handleInstagramMedia(message, topicId);
          break;

        case 'voice_media':
          await this.handleInstagramVoice(message, topicId);
          break;

        case 'animated_media':
          await this.handleInstagramAnimatedMedia(message, topicId);
          break;

        case 'like':
          await this.sendSimpleMessage(topicId, '‚ù§Ô∏è');
          break;

        default:
          const fallbackText = `[${message.type}] ${message.text || 'Unsupported message type'}`;
          await this.sendSimpleMessage(topicId, fallbackText);
      }
    } catch (error) {
      logger.error('‚ùå Error forwarding message type:', error.message);
    }
  }

  async handleInstagramMedia(message, topicId) {
    try {
      const mediaData = message.raw.media;
      if (!mediaData) return;

      let mediaUrl;
      if (mediaData.image_versions2?.candidates?.length > 0) {
        mediaUrl = mediaData.image_versions2.candidates[0].url;
      } else if (mediaData.video_versions?.length > 0) {
        mediaUrl = mediaData.video_versions[0].url;
      }

      if (mediaUrl) {
        const caption = message.text || '';
        
        if (mediaData.media_type === 1) { // Photo
          await this.telegramBot.sendPhoto(this.telegramChatId, mediaUrl, {
            message_thread_id: topicId,
            caption: caption
          });
        } else if (mediaData.media_type === 2) { // Video
          await this.telegramBot.sendVideo(this.telegramChatId, mediaUrl, {
            message_thread_id: topicId,
            caption: caption
          });
        }
      }
    } catch (error) {
      logger.error('‚ùå Error handling Instagram media:', error.message);
      await this.sendSimpleMessage(topicId, `[Media] ${message.text || 'Failed to load media'}`);
    }
  }

  async handleInstagramVoice(message, topicId) {
    try {
      const voiceData = message.raw.voice_media;
      if (voiceData?.media?.audio?.audio_src) {
        await this.telegramBot.sendVoice(this.telegramChatId, voiceData.media.audio.audio_src, {
          message_thread_id: topicId,
          duration: Math.floor(voiceData.media.audio.duration / 1000)
        });
      }
    } catch (error) {
      logger.error('‚ùå Error handling voice message:', error.message);
      await this.sendSimpleMessage(topicId, 'üéµ Voice message (failed to load)');
    }
  }

  async handleInstagramAnimatedMedia(message, topicId) {
    try {
      const animatedData = message.raw.animated_media;
      if (animatedData?.images?.fixed_height?.url) {
        await this.telegramBot.sendAnimation(this.telegramChatId, animatedData.images.fixed_height.url, {
          message_thread_id: topicId
        });
      }
    } catch (error) {
      logger.error('‚ùå Error handling animated media:', error.message);
      await this.sendSimpleMessage(topicId, 'üé≠ GIF/Sticker (failed to load)');
    }
  }

  async sendSimpleMessage(topicId, text) {
    try {
      await this.telegramBot.sendMessage(this.telegramChatId, text, {
        message_thread_id: topicId
      });
    } catch (error) {
      logger.error('‚ùå Failed to send simple message:', error.message);
    }
  }

  async setupTelegramHandlers() {
    this.telegramBot.on('message', async (msg) => {
      if (msg.chat.type === 'supergroup' && msg.is_topic_message && msg.message_thread_id) {
        await this.handleTelegramMessage(msg);
      }
    });

    this.telegramBot.on('polling_error', (error) => {
      logger.error('Telegram polling error:', error.message);
    });

    logger.info('üì± Telegram handlers set up');
  }

  async handleTelegramMessage(msg) {
    try {
      const topicId = msg.message_thread_id;
      const instagramThreadId = this.findInstagramThreadIdByTopic(topicId);

      if (!instagramThreadId) {
        await this.setReaction(msg.chat.id, msg.message_id, '‚ùì');
        return;
      }

      await this.setReaction(msg.chat.id, msg.message_id, 'üîÑ');

      let success = false;

      if (msg.text) {
        success = await this.instagramBot.sendMessage(instagramThreadId, msg.text);
      } else if (msg.photo) {
        success = await this.handleTelegramPhoto(msg, instagramThreadId);
      } else if (msg.video) {
        success = await this.handleTelegramVideo(msg, instagramThreadId);
      } else if (msg.voice) {
        success = await this.handleTelegramVoice(msg, instagramThreadId);
      } else if (msg.document) {
        success = await this.handleTelegramDocument(msg, instagramThreadId);
      }

      await this.setReaction(msg.chat.id, msg.message_id, success ? '‚úÖ' : '‚ùå');

    } catch (error) {
      logger.error('‚ùå Error handling Telegram message:', error.message);
      await this.setReaction(msg.chat.id, msg.message_id, '‚ùå');
    }
  }

  async handleTelegramPhoto(msg, instagramThreadId) {
    try {
      const fileId = msg.photo[msg.photo.length - 1].file_id;
      const fileLink = await this.telegramBot.getFileLink(fileId);
      const response = await axios.get(fileLink, { responseType: 'arraybuffer' });
      
      // Convert to JPEG and resize for Instagram
      const processedImage = await sharp(Buffer.from(response.data))
        .jpeg({ quality: 85 })
        .resize(1080, 1080, { fit: 'inside', withoutEnlargement: true })
        .toBuffer();

      await this.instagramBot.sendPhoto(instagramThreadId, processedImage, msg.caption);
      return true;
    } catch (error) {
      logger.error('‚ùå Error handling Telegram photo:', error.message);
      return false;
    }
  }

  async handleTelegramVideo(msg, instagramThreadId) {
    try {
      const fileLink = await this.telegramBot.getFileLink(msg.video.file_id);
      const response = await axios.get(fileLink, { responseType: 'arraybuffer' });
      
      // Note: Instagram has strict video requirements
      // This is a basic implementation - you might need ffmpeg for proper conversion
      await this.instagramBot.sendMessage(instagramThreadId, 
        `üé• Video received: ${msg.video.file_name || 'video'}\n${msg.caption || ''}`);
      return true;
    } catch (error) {
      logger.error('‚ùå Error handling Telegram video:', error.message);
      return false;
    }
  }

  async handleTelegramVoice(msg, instagramThreadId) {
    try {
      const fileLink = await this.telegramBot.getFileLink(msg.voice.file_id);
      const response = await axios.get(fileLink, { responseType: 'arraybuffer' });
      
      await this.instagramBot.sendVoice(instagramThreadId, Buffer.from(response.data));
      return true;
    } catch (error) {
      logger.error('‚ùå Error handling Telegram voice:', error.message);
      return false;
    }
  }

  async handleTelegramDocument(msg, instagramThreadId) {
    try {
      const fileName = msg.document.file_name || 'document';
      const fileSize = (msg.document.file_size / 1024).toFixed(2);
      
      await this.instagramBot.sendMessage(instagramThreadId, 
        `üìé Document: ${fileName} (${fileSize} KB)\n${msg.caption || ''}`);
      return true;
    } catch (error) {
      logger.error('‚ùå Error handling Telegram document:', error.message);
      return false;
    }
  }

  async setReaction(chatId, messageId, emoji) {
    try {
      const token = config.telegram?.botToken;
      await axios.post(`https://api.telegram.org/bot${token}/setMessageReaction`, {
        chat_id: chatId,
        message_id: messageId,
        reaction: [{ type: 'emoji', emoji: emoji }]
      });
    } catch (error) {
      logger.debug('Failed to set reaction:', error.message);
    }
  }

  findInstagramThreadIdByTopic(topicId) {
    for (const [threadId, topic] of this.chatMappings.entries()) {
      if (topic === topicId) {
        return threadId;
      }
    }
    return null;
  }

  async shutdown() {
    logger.info('üõë Shutting down Telegram bridge...');
    
    if (this.telegramBot) {
      try {
        await this.telegramBot.stopPolling();
      } catch (error) {
        logger.debug('Error stopping polling:', error.message);
      }
    }

    try {
      await fs.emptyDir(this.tempDir);
    } catch (error) {
      logger.debug('Could not clean temp directory:', error.message);
    }

    logger.info('‚úÖ Telegram bridge shutdown complete');
  }
}










