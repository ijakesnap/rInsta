import { logger, fileUtils, messageUtils } from '../utils.js';
import { config } from '../config.js';

export class MessageLoggerPlugin {
  constructor() {
    this.name = 'MessageLogger';
    this.config = config.plugins.messageLogger;
    this.messages = [];
    this.loggedCount = 0;
  }

  async process(message) {
    try {
      // Skip if message logger is disabled
      if (!this.config.enabled) {
        return message;
      }

      // Format and store the message
      const formattedMessage = messageUtils.formatMessage(message);
      formattedMessage.logged_at = new Date().toISOString();
      
      this.messages.push(formattedMessage);
      this.loggedCount++;

      // Save to file periodically or when reaching max size
      if (this.messages.length >= this.config.maxLogSize || this.loggedCount % 10 === 0) {
        await this.saveMessages();
      }

      logger.debug(`📝 Logged message from @${message.senderUsername}`);

    } catch (error) {
      logger.error('Error in MessageLogger plugin:', error);
    }

    return message;
  }

  async saveMessages() {
    try {
      // Load existing messages
      let existingMessages = [];
      if (await fileUtils.pathExists(this.config.logPath)) {
        existingMessages = await fileUtils.readJson(this.config.logPath) || [];
      }

      // Combine with new messages
      const allMessages = [...existingMessages, ...this.messages];

      // Keep only the latest messages (within max log size)
      const messagesToKeep = allMessages.slice(-this.config.maxLogSize);

      // Save to file
      await fileUtils.writeJson(this.config.logPath, messagesToKeep);

      logger.info(`💾 Saved ${this.messages.length} messages to log file`);
      
      // Clear the buffer
      this.messages = [];

    } catch (error) {
      logger.error('Error saving messages to log:', error);
    }
  }

  async getMessages(limit = 50) {
    try {
      if (await fileUtils.pathExists(this.config.logPath)) {
        const messages = await fileUtils.readJson(this.config.logPath) || [];
        return messages.slice(-limit);
      }
      return [];
    } catch (error) {
      logger.error('Error reading messages from log:', error);
      return [];
    }
  }

  async searchMessages(query, limit = 20) {
    try {
      const messages = await this.getMessages(1000); // Get more messages for search
      const filtered = messages.filter(msg => 
        msg.text.toLowerCase().includes(query.toLowerCase()) ||
        msg.sender.toLowerCase().includes(query.toLowerCase())
      );
      return filtered.slice(-limit);
    } catch (error) {
      logger.error('Error searching messages:', error);
      return [];
    }
  }

  getStats() {
    return {
      loggedCount: this.loggedCount,
      bufferedMessages: this.messages.length,
      logPath: this.config.logPath
    };
  }

  async cleanup() {
    // Save any remaining messages
    if (this.messages.length > 0) {
      await this.saveMessages();
    }
    logger.info(`🧹 MessageLogger plugin cleaned up. Logged ${this.loggedCount} messages total`);
  }
}
